<div class="content">
  <h3>컨트롤러</h3>
  <p>
    Controllers are responsible for handling incoming <strong>requests</strong> and returning <strong>responses</strong>
    to the client.</p>
  <figure><img src="/assets/Controllers_1.png" /></figure>
  <p>
    In order to create a basic controller, we use <strong>decorators</strong>. Decorators associate classes with the essential
    metadata for Nest to know how to map controllers to the corresponding routes.
  </p>
  <h4>데코레이터</h4>
  <p>
    In the following example we'll use the <code>@Controller()</code> decorator which is <strong>required</strong> to define
    a basic controller. We'll specify an optional prefix of <code>cats</code>. Using a prefix in a Controller decoraror allows
    us to avoid repeating ourselves when routes could potentially share a common prefix.
  </p>
  <span class="filename">
    {{ 'cats.controller' | extension: catsControllerT.isJsActive }}
    <app-tabs #catsControllerT></app-tabs>
  </span>
  <pre><code class="language-typescript">{{ catsController }}</code></pre>
  <h4>데코레이터</h4>
  <p>
    The <code>@Get()</code> decorator before the <code>findAll()</code> method tells Nest to create an endpoint for this
    particular route path and map every corresponding request to this handler. Since we've declared a prefix for every route
    (
    <code>cats</code>), Nest will map every <code>/cats</code> <strong>GET</strong> request to this method.
  </p>
  <p>
    When a GET request is made to this endpoint, Nest will now return a 200 status code and the parsed <strong>JSON</strong>
    response, which in this case just an empty array. Why does that happen? Generally, we distinguish <strong>two different
      approaches
    </strong> to manipulate responses:
  </p>
  <table>
    <tr>
      <td>Standard (recommended)</td>
      <td>
        When we return a JavaScript object or array, it'll be <strong>automatically</strong>
        parsed to JSON. When we return a string however, Nest will send just a string without attempting to parse it.
        <br />
        <br /> Furthermore, the response's <strong>status code</strong> is always 200 by default, except for POST requests
        which use <strong>201</strong>. We can easily change this behaviour by adding the <code>@HttpCode(...)</code> decorator
        at a handler-level.
      </td>
    </tr>
    <tr>
      <td>Library-specific</td>
      <td>
        We can use the library specific <a href="http://expressjs.com/en/api.html#res" target="blank">response object</a>,
        which we can inject using the <code>@Res()</code> decorator in the function signature (e.g. <code>findAll(@Res() response)</code>).
      </td>
    </tr>
  </table>
  <blockquote>
    <strong>Warning</strong> It's forbidden to use both approaches at the same time. Nest detects whether the handler is
    using either <code>@Res()</code> or <code>@Next()</code>. If both approaches are used in the same time - the Standard
    approach is automatically disabled for this single route and will no longer work as expected.
  </blockquote>
  <h4>요청(Request) 객체</h4>
  <p>
    A lot of endpoints need access to the client <strong>request</strong> details. In fact, Nest is using a library-specific
    (express by default) <a href="http://expressjs.com/en/api.html#req" target="blank">request object</a>. As a result, we
    can force Nest to inject the request object into the handler using the <code>@Req()</code> decorator.
  </p>
  <span class="filename">
    {{ 'cats.controller' | extension: requestObjectT.isJsActive }}
    <app-tabs #requestObjectT></app-tabs>
  </span>
  <pre [class.hide]="requestObjectT.isJsActive"><code class="language-typescript">{{ requestObject }}</code></pre>
  <pre [class.hide]="!requestObjectT.isJsActive"><code class="language-typescript">{{ requestObjectJs }}</code></pre>
  <p>
    The request object represents the HTTP request and has properties for the request query string, parameters, HTTP headers,
    and body (read more <a href="http://expressjs.com/en/api.html#req" target="blank">here</a>). In most cases, it's
    not necessary to grab these properties manually. We can use <strong>dedicated decorators</strong> instead, such as <code>@Body()</code>    or
    <code>@Query()</code>, which are available out of the box. Below is a comparison of the provided decorators and the plain
    express objects they represent.
  </p>
  <table>
    <tbody>
      <tr>
        <td><code>@Request()</code></td>
        <td><code>req</code></td>
      </tr>
      <tr>
        <td><code>@Response()</code></td>
        <td><code>res</code></td>
      </tr>
      <tr>
        <td><code>@Next()</code></td>
        <td><code>next</code></td>
      </tr>
      <tr>
        <td><code>@Session()</code></td>
        <td><code>req.session</code></td>
      </tr>
      <tr>
        <td><code>@Param(param?: string)</code></td>
        <td><code>req.params</code> / <code>req.params[param]</code></td>
      </tr>
      <tr>
        <td><code>@Body(param?: string)</code></td>
        <td><code>req.body</code> / <code>req.body[param]</code></td>
      </tr>
      <tr>
        <td><code>@Query(param?: string)</code></td>
        <td><code>req.query</code> / <code>req.query[param]</code></td>
      </tr>
      <tr>
        <td><code>@Headers(param?: string)</code></td>
        <td><code>req.headers</code> / <code>req.headers[param]</code></td>
      </tr>
    </tbody>
  </table>
  <h4>엔드포인트 정의하기</h4>
  <p>
    We defined an endpoint to fetch the data (<strong>GET</strong> route). It'll also be great to provide a way of creating
    new records as well. For this, let's create the <strong>POST</strong> handler:
  </p>
  <span class="filename">
    {{ 'cats.controller' | extension: postEndpointT.isJsActive }}
    <app-tabs #postEndpointT></app-tabs>
  </span>
  <pre><code class="language-typescript">{{ postEndpoint }}</code></pre>
  <p>
    It's that simple. Nest provides the rest of those endpoint decorators in the same fashion -
    <code>@Put()</code>, <code>@Delete()</code>, <code>@Patch()</code>, <code>@Options()</code>, <code>@Head()</code>, and
    <code>@All()</code>.
  </p>
  <h4>상태코드</h4>
  <p>
    As mentioned, the response <strong>status code</strong> is always <strong>200</strong> by default, except for POST requests
    which are <strong>201</strong>. We can easily change this behaviour by adding the <code>@HttpCode(...)</code> decorator
    at a handler-level.
  </p>
  <pre><code class="language-typescript">{{ statusCode }}</code></pre>
  <h4>응답(Response) 헤더</h4>
  <p>
    To specify a custom response header, you can either use a <code>@Header()</code> decorator or a library-specific request
    object.
  </p>
  <pre><code class="language-typescript">{{ header }}</code></pre>
  <h4>라우트 파라미터</h4>
  <p>
    Routes with static paths can't help when you need to accept <strong>dynamic data</strong> as part of the URL. In order
    to define routes with parameters, we can directly specify the route parameters in the path of the route.
  </p>
  <pre><code class="language-typescript">{{ routeParameters }}</code></pre>
  <p>
    In order to pick up a particular parameter, simply pass its name in parenthesis.
  </p>
  <pre><code class="language-typescript">{{ routeParameter }}</code></pre>
  <h4>Async / await</h4>
  <p>
    We love modern JavaScript and we know that data extraction is mostly <strong>asynchronous</strong>. That's why Nest supports
    and works well with <code>async</code> functions.
  </p>
  <blockquote class="info">
    <strong>Hint</strong> Learn more about <code>async / await</code> <a href="https://kamilmysliwiec.com/typescript-2-1-introduction-async-await"
      target="blank">here</a>!
  </blockquote>
  <p>
    Every async function has to return a <code>Promise</code>. It means that you can return a deferred value that Nest will
    be able to resolve by itself. Let's see an example of this below:
  </p>
  <span class="filename">
    {{ 'cats.controller' | extension: asyncExampleT.isJsActive }}
    <app-tabs #asyncExampleT></app-tabs>
  </span>
  <pre [class.hide]="asyncExampleT.isJsActive"><code class="language-typescript">{{ asyncExample }}</code></pre>
  <pre [class.hide]="!asyncExampleT.isJsActive"><code class="language-typescript">{{ asyncExampleJs }}</code></pre>
  <p>
    The above code is fully valid.
  </p>
  <p>
    Furthermore, Nest route handlers are even more powerful by being able to return RxJS
    <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html" target="blank">observable streams</a>. Nest
    will automatically subscribe to the source underneath and take the first emitted value.
  </p>
  <span class="filename">
    {{ 'cats.controller' | extension: observableExampleT.isJsActive }}
    <app-tabs #observableExampleT></app-tabs>
  </span>
  <pre [class.hide]="observableExampleT.isJsActive"><code class="language-typescript">{{ observableExample }}</code></pre>
  <pre [class.hide]="!observableExampleT.isJsActive"><code class="language-typescript">{{ observableExampleJs }}</code></pre>
  <p>
    Either of the above approaches work and you can use whatever fits your requirements.
  </p>
  <h4>POST 핸들러</h4>
  <p>
    Our previous example of the POST route handler didn't accept any client params. Let's fix this by adding the <code>@Body()</code>    argument
    here.
  </p>
  <p>
    But first (if you use TypeScript), we need to determine the <strong>DTO</strong> (Data Transfer Object) schema. A DTO
    is an object that defines how the data will be sent over the network. We could determine the DTO schema by using <strong>TypeScript</strong>
    interfaces, or by simple classes. Surprisingly, we recommend using <strong>classes</strong> here. Why? Classes are part
    of the JavaScript ES6 standard, and therefore they represent plain functions. On the other hand, since TypeScript interfaces
    are removed during the transpilation, Nest can't refer to them. This is important because features such as <strong>Pipes</strong>
    enable additional possibilities when they have access to the metatype of the variable.
  </p>
  <p>
    Let's create the <code>CreateCatDto</code> class:
  </p>
  <span class="filename">
    {{ 'create-cat.dto' | extension: createCatSchemaT.isJsActive }}
    <app-tabs #createCatSchemaT></app-tabs>
  </span>
  <pre><code class="language-typescript">{{ createCatSchema }}</code></pre>
  <p>
    It has only three basic properties. All of them are marked as <code>readonly</code> because we should always try to make
    our functions as <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976"
      target="blank">pure</a> as possible.
  </p>
  <p>
    Thereafter we can use the newly created schema inside the <code>CatsController</code>:
  </p>
  <span class="filename">
    {{ 'cats.controller' | extension: exampleWithBodyT.isJsActive }}
    <app-tabs #exampleWithBodyT></app-tabs>
  </span>
  <pre [class.hide]="exampleWithBodyT.isJsActive"><code class="language-typescript">{{ exampleWithBody }}</code></pre>
  <pre [class.hide]="!exampleWithBodyT.isJsActive"><code class="language-typescript">{{ exampleWithBodyJs }}</code></pre>
  <h4>전체 예제</h4>
  <p>
    Here is a example that makes use of a few available decorators to create a basic controller. The following controller exposes
    a couple of methods to access and manipulate internal data.
  </p>
  <span class="filename">
    {{ 'cats.controller' | extension: fullSampleT.isJsActive }}
    <app-tabs #fullSampleT></app-tabs>
  </span>
  <pre [class.hide]="fullSampleT.isJsActive"><code class="language-typescript">{{ fullSample }}</code></pre>
  <pre [class.hide]="!fullSampleT.isJsActive"><code class="language-typescript">{{ fullSample }}</code></pre>
  <h4>에러 핸들링</h4>
  <p>
    There's a separate chapter about handling errors (i.e. working with exceptions) <a routerLink="/exception-filters">here</a>.
  </p>
  <h4>마지막 단계</h4>
  <p>
    With the above controller fully prepared, Nest still doesn't know that <code>CatsController</code> exists and as a result
    won't create an instance of this class.
  </p>
  <p>
    Controllers always belong to the module, which is why we hold the <code>controllers</code> array within the <code>@Module()</code>    decorator.
    Since we don't have any other modules except the root <code>ApplicationModule</code>, we'll use that to introduce the
    <code>CatsController</code>:
  </p>
  <span class="filename">
    {{ 'app.module' | extension: appModuleT.isJsActive }}
    <app-tabs #appModuleT></app-tabs>
  </span>
  <pre><code class="language-typescript">{{ appModule }}</code></pre>
  <p>
    Tada! We attached the metadata to the module class, and Nest can now easily reflect which controllers have to be mounted.
  </p>
  <h4>라이브러리에 의존한 접근법</h4>
  <p>
    So far we've discussed the Nest standard way of manipulating responses. The second way of manipulating the response is to
    use a library-specific <a href="http://expressjs.com/en/api.html#res" target="blank">response object</a>. In order
    to inject a particular response object, we need to use the <code>@Res()</code> decorator. To show the differences, let's
    rewrite the <code>CatsController</code> to the following:
  </p>
  <span class="filename">
    <app-tabs #expressWayT></app-tabs>
  </span>
  <pre [class.hide]="expressWayT.isJsActive"><code class="language-typescript">{{ expressWay }}</code></pre>
  <pre [class.hide]="!expressWayT.isJsActive"><code class="language-typescript">{{ expressWayJs }}</code></pre>
  <p>
    Though this approach works, its much less clear in general. The first approach should always be prepared, but to make Nest
    <strong>backwards compatible</strong>
    with previous versions, the above approach is still available. One other thing to note is the <strong>response object</strong>
    in this approach allows for more flexibility - by allowing us to have full control of the response object (headers manipulation
    and so on).
  </p>
</div>